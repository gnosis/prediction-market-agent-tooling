Index: prediction_market_agent_tooling/tools/cow/cow_order.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio\nfrom datetime import timedelta\n\nimport httpx\nfrom cow_py import swap_tokens\nfrom cow_py.common.chains import Chain\nfrom cow_py.common.constants import CowContractAddress\nfrom cow_py.order_book.config import Envs\nfrom cow_py.order_book.generated.model import OrderMetaData, OrderStatus\nfrom eth_account.signers.local import LocalAccount\nfrom web3 import Web3\n\nfrom prediction_market_agent_tooling.config import APIKeys\nfrom prediction_market_agent_tooling.gtypes import ChecksumAddress, Wei, xDai\nfrom prediction_market_agent_tooling.loggers import logger\nfrom prediction_market_agent_tooling.tools.contract import ContractERC20OnGnosisChain\nfrom prediction_market_agent_tooling.tools.utils import utcnow\nfrom prediction_market_agent_tooling.tools.web3_utils import xdai_to_wei\n\n\ndef swap_tokens_waiting(\n    amount: xDai,\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n    api_keys: APIKeys,\n    chain: Chain = Chain.GNOSIS,\n    env: Envs = \"prod\",\n    web3: Web3 | None = None,\n) -> OrderMetaData:\n    amount_wei = xdai_to_wei(amount)\n    account = api_keys.get_account()\n\n    # Approve the CoW Swap Vault Relayer to get the sell token.\n    ContractERC20OnGnosisChain(address=sell_token).approve(\n        api_keys,\n        Web3.to_checksum_address(CowContractAddress.VAULT_RELAYER.value),\n        amount_wei=amount_wei,\n        web3=web3,\n    )\n\n    # CoW library uses async, so we need to wrap the call in asyncio.run for us to use it.\n    return asyncio.run(\n        swap_tokens_waiting_async(\n            amount_wei, sell_token, buy_token, account, chain, env\n        )\n    )\n\n\nasync def swap_tokens_waiting_async(\n    amount_wei: Wei,\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n    account: LocalAccount,\n    chain: Chain,\n    env: Envs,\n    timeout: timedelta = timedelta(seconds=60),\n) -> OrderMetaData:\n    order = await swap_tokens(\n        amount=amount_wei,\n        sell_token=sell_token,\n        buy_token=buy_token,\n        account=account,\n        chain=chain,\n        env=env,\n    )\n    logger.info(f\"Order created: {order}\")\n    start_time = utcnow()\n\n    while True:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(order.url)\n            order_metadata = OrderMetaData.model_validate(response.json())\n\n        if order_metadata.status in (\n            OrderStatus.fulfilled,\n            OrderStatus.cancelled,\n            OrderStatus.expired,\n        ):\n            return order_metadata\n\n        if utcnow() - start_time > timeout:\n            raise TimeoutError(\"Timeout waiting for order to be completed.\")\n\n        await asyncio.sleep(3.14)\n
===================================================================
diff --git a/prediction_market_agent_tooling/tools/cow/cow_order.py b/prediction_market_agent_tooling/tools/cow/cow_order.py
--- a/prediction_market_agent_tooling/tools/cow/cow_order.py	
+++ b/prediction_market_agent_tooling/tools/cow/cow_order.py	
@@ -66,6 +66,7 @@
     logger.info(f"Order created: {order}")
     start_time = utcnow()
 
+    client = httpx.AsyncClient()
     while True:
         async with httpx.AsyncClient() as client:
             response = await client.get(order.url)
