Index: prediction_market_agent_tooling/markets/omen/data_models.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import typing as t\n\nfrom pydantic import BaseModel, ConfigDict, Field, computed_field, model_validator\nfrom web3 import Web3\n\nfrom prediction_market_agent_tooling.gtypes import (\n    USD,\n    ChecksumAddress,\n    CollateralToken,\n    HexAddress,\n    HexBytes,\n    HexStr,\n    OutcomeStr,\n    OutcomeWei,\n    Probability,\n    Wei,\n    xDai,\n    xDaiWei,\n)\nfrom prediction_market_agent_tooling.loggers import logger\nfrom prediction_market_agent_tooling.markets.data_models import (\n    Bet,\n    Resolution,\n    ResolvedBet,\n)\nfrom prediction_market_agent_tooling.tools.contract import (\n    ContractERC20OnGnosisChain,\n    init_collateral_token_contract,\n    to_gnosis_chain_contract,\n)\nfrom prediction_market_agent_tooling.tools.tokens.usd import get_token_in_usd\nfrom prediction_market_agent_tooling.tools.utils import (\n    BPS_CONSTANT,\n    DatetimeUTC,\n    check_not_none,\n    should_not_happen,\n    utcnow,\n)\n\nOMEN_TRUE_OUTCOME = OutcomeStr(\"Yes\")\nOMEN_FALSE_OUTCOME = OutcomeStr(\"No\")\nOMEN_BINARY_MARKET_OUTCOMES: t.Sequence[OutcomeStr] = [\n    OMEN_TRUE_OUTCOME,\n    OMEN_FALSE_OUTCOME,\n]\nINVALID_ANSWER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\nINVALID_ANSWER_HEX_BYTES = HexBytes(INVALID_ANSWER)\nINVALID_ANSWER_STR = HexStr(INVALID_ANSWER_HEX_BYTES.hex())\nOMEN_BASE_URL = \"https://aiomen.eth.limo\"\nPRESAGIO_BASE_URL = \"https://presagio.pages.dev\"\nTEST_CATEGORY = \"test\"  # This category is hidden on Presagio for testing purposes.\n\n\ndef construct_presagio_url(market_id: HexAddress) -> str:\n    return f\"{PRESAGIO_BASE_URL}/markets?id={market_id}\"\n\n\ndef get_boolean_outcome(outcome_str: str) -> bool:\n    if outcome_str == OMEN_TRUE_OUTCOME:\n        return True\n    if outcome_str == OMEN_FALSE_OUTCOME:\n        return False\n    raise ValueError(f\"Outcome `{outcome_str}` is not a valid boolean outcome.\")\n\n\ndef get_bet_outcome(binary_outcome: bool) -> str:\n    return OMEN_TRUE_OUTCOME if binary_outcome else OMEN_FALSE_OUTCOME\n\n\nclass Condition(BaseModel):\n    id: HexBytes\n    outcomeSlotCount: int\n\n    @property\n    def index_sets(self) -> t.List[int]:\n        return [i + 1 for i in range(self.outcomeSlotCount)]\n\n\nclass Question(BaseModel):\n    id: HexBytes\n    title: str\n    data: str\n    templateId: int\n    outcomes: t.Sequence[OutcomeStr]\n    isPendingArbitration: bool\n    openingTimestamp: int\n    answerFinalizedTimestamp: t.Optional[DatetimeUTC] = None\n    currentAnswer: t.Optional[str] = None\n\n    @property\n    def question_id(self) -> HexBytes:\n        return self.id\n\n    @property\n    def question_raw(self) -> str:\n        # Based on https://github.com/protofire/omen-exchange/blob/2cfdf6bfe37afa8b169731d51fea69d42321d66c/app/src/hooks/graph/useGraphMarketMakerData.tsx#L217.\n        return self.data\n\n    @property\n    def n_outcomes(self) -> int:\n        return len(self.outcomes)\n\n    @property\n    def opening_datetime(self) -> DatetimeUTC:\n        return DatetimeUTC.to_datetime_utc(self.openingTimestamp)\n\n    @property\n    def has_answer(self) -> bool:\n        return self.currentAnswer is not None\n\n    @property\n    def outcome_index(self) -> int | None:\n        return (\n            int(\n                self.currentAnswer,\n                16,\n            )\n            if self.currentAnswer is not None\n            else None\n        )\n\n    @property\n    def is_binary(self) -> bool:\n        return len(self.outcomes) == 2\n\n    @property\n    def has_valid_answer(self) -> bool:\n        return self.outcome_index is not None and self.outcome_index != INVALID_ANSWER\n\n    @property\n    def boolean_outcome(self) -> bool:\n        if not self.is_binary:\n            raise ValueError(\n                f\"Question with title {self.title} is not binary, it has {len(self.outcomes)} outcomes.\"\n            )\n\n        if not self.has_answer:\n            raise ValueError(f\"Question with title {self.title} is not answered.\")\n\n        outcome_index = check_not_none(self.outcome_index)\n\n        if not self.has_valid_answer:\n            raise ValueError(\n                f\"Question with title {self.title} has invalid answer {outcome_index}.\"\n            )\n\n        outcome: str = self.outcomes[outcome_index]\n        return get_boolean_outcome(outcome)\n\n\nclass OmenPosition(BaseModel):\n    id: HexBytes\n    conditionIds: list[HexBytes]\n    collateralTokenAddress: HexAddress\n    indexSets: list[int]\n\n    @property\n    def condition_id(self) -> HexBytes:\n        # I didn't find any example where this wouldn't hold, but keeping this double-check here in case something changes in the future.\n        # May be the case if the market is created with multiple oracles.\n        if len(self.conditionIds) != 1:\n            raise ValueError(\n                f\"Bug in the logic, please investigate why zero or multiple conditions are returned for position {self.id=}\"\n            )\n        return self.conditionIds[0]\n\n    @property\n    def index_set(self) -> int:\n        if len(self.indexSets) != 1:\n            raise ValueError(\n                f\"Bug in the logic, please investigate why zero or multiple index sets are returned for position {self.id=}\"\n            )\n        return self.indexSets[0]\n\n    @property\n    def collateral_token_contract_address_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.collateralTokenAddress)\n\n    def get_collateral_token_contract(\n        self, web3: Web3 | None\n    ) -> ContractERC20OnGnosisChain:\n        web3 = web3 or ContractERC20OnGnosisChain.get_web3()\n        return to_gnosis_chain_contract(\n            init_collateral_token_contract(\n                self.collateral_token_contract_address_checksummed, web3\n            )\n        )\n\n\nclass OmenUserPosition(BaseModel):\n    id: HexBytes\n    position: OmenPosition\n    balance: OutcomeWei\n    wrappedBalance: OutcomeWei\n    totalBalance: OutcomeWei\n\n    @property\n    def redeemable(self) -> bool:\n        return self.totalBalance > 0\n\n\nclass OmenMarket(BaseModel):\n    \"\"\"\n    https://presagio.pages.dev\n\n    An Omen market goes through the following stages:\n\n    1. creation - can add liquidty immediately, and trade immediately if there is liquidity\n    2. closing - market is closed, and a question is simultaneously opened for answers on Reality\n    3. finalizing - the question is finalized on reality (including any disputes)\n    4. resolving - a manual step required by calling the Omen oracle contract\n    5. redeeming - a user withdraws collateral tokens from the market\n    \"\"\"\n\n    id: HexAddress\n    title: str\n    creator: HexAddress\n    category: str\n    collateralVolume: Wei\n    # Note: there are two similar parameters relating to liquidity:\n    # liquidityParameter and liquidityMeasure. The former appears to match most\n    # closely with the liquidity returned when calling the contract directly\n    # (see OmenAgentMarket.get_liquidity). So we can use it e.g. for filtering\n    # markets, but until better understood, please call the contract directly.\n    liquidityParameter: Wei\n    usdVolume: USD\n    collateralToken: HexAddress\n    outcomes: t.Sequence[OutcomeStr]\n    outcomeTokenAmounts: list[OutcomeWei]\n    outcomeTokenMarginalPrices: t.Optional[list[CollateralToken]]\n    fee: t.Optional[Wei]\n    resolutionTimestamp: t.Optional[int] = None\n    answerFinalizedTimestamp: t.Optional[int] = None\n    currentAnswer: t.Optional[HexBytes] = None\n    creationTimestamp: int\n    condition: Condition\n    question: Question\n\n    @model_validator(mode=\"after\")\n    def _model_validator(self) -> \"OmenMarket\":\n        if any(number < 0 for number in self.outcomeTokenAmounts):\n            # Sometimes we receive markets with outcomeTokenAmounts as `model.outcomeTokenAmounts=[OutcomeWei(24662799387878572), OutcomeWei(-24750000000000000)]`,\n            # which should be impossible.\n            # Current huntch is that it's a weird transitional status or bug after withdrawing liquidity.\n            # Because so far, it always happened on markets with withdrawn liquidity,\n            # so we just set them to zeros, as we expect them to be.\n            logger.warning(\n                f\"Market {self.url} has invalid {self.outcomeTokenAmounts=}. Setting them to zeros.\"\n            )\n            self.outcomeTokenAmounts = [OutcomeWei(0) for _ in self.outcomes]\n            self.outcomeTokenMarginalPrices = None\n            self.liquidityParameter = Wei(0)\n\n        return self\n\n    @property\n    def openingTimestamp(self) -> int:\n        # This field is also available on this model itself, but for some reason it's typed to be optional,\n        # but Question's openingTimestamp is typed to be always present, so use that one instead.\n        return self.question.openingTimestamp\n\n    @property\n    def opening_datetime(self) -> DatetimeUTC:\n        return DatetimeUTC.to_datetime_utc(self.openingTimestamp)\n\n    @property\n    def close_time(self) -> DatetimeUTC:\n        # Opening of the Reality's question is close time for the market,\n        # however, market is usually \"closed\" even sooner by removing all the liquidity.\n        return self.opening_datetime\n\n    @property\n    def answer_index(self) -> t.Optional[int]:\n        return self.currentAnswer.as_int() if self.currentAnswer else None\n\n    @property\n    def has_valid_answer(self) -> bool:\n        return self.answer_index is not None and self.answer_index != INVALID_ANSWER\n\n    @property\n    def is_open(self) -> bool:\n        return self.close_time > utcnow()\n\n    @property\n    def is_resolved(self) -> bool:\n        return (\n            # Finalized on Realitio (e.g. 24h has passed since the last answer was submitted)\n            self.answerFinalizedTimestamp is not None\n            # Resolved on Oracle (e.g. resolved after it was finalized)\n            and self.resolutionTimestamp is not None\n        )\n\n    @property\n    def is_resolved_with_valid_answer(self) -> bool:\n        return self.is_resolved and self.has_valid_answer\n\n    @property\n    def question_title(self) -> str:\n        return self.title\n\n    @property\n    def creation_datetime(self) -> DatetimeUTC:\n        return DatetimeUTC.to_datetime_utc(self.creationTimestamp)\n\n    @property\n    def finalized_datetime(self) -> DatetimeUTC | None:\n        return (\n            DatetimeUTC.to_datetime_utc(self.answerFinalizedTimestamp)\n            if self.answerFinalizedTimestamp is not None\n            else None\n        )\n\n    @property\n    def has_bonded_outcome(self) -> bool:\n        return self.finalized_datetime is not None\n\n    @property\n    def market_maker_contract_address(self) -> HexAddress:\n        return self.id\n\n    @property\n    def market_maker_contract_address_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.market_maker_contract_address)\n\n    @property\n    def collateral_token_contract_address(self) -> HexAddress:\n        return self.collateralToken\n\n    @property\n    def collateral_token_contract_address_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.collateral_token_contract_address)\n\n    @property\n    def outcomeTokenProbabilities(self) -> t.Optional[list[Probability]]:\n        return (\n            [Probability(float(x)) for x in self.outcomeTokenMarginalPrices]\n            if self.outcomeTokenMarginalPrices is not None\n            else None\n        )\n\n    @property\n    def yes_index(self) -> int:\n        return self.outcomes.index(OMEN_TRUE_OUTCOME)\n\n    @property\n    def no_index(self) -> int:\n        return self.outcomes.index(OMEN_FALSE_OUTCOME)\n\n    @property\n    def current_p_no(self) -> Probability:\n        return Probability(1 - self.current_p_yes)\n\n    @property\n    def current_p_yes(self) -> Probability:\n        \"\"\"\n        Calculate the probability of the outcomes from the relative token amounts.\n\n        Note, not all markets reliably have outcomeTokenMarginalPrices, hence we\n        use the relative proportion of outcomeTokenAmounts to calculate the\n        probabilities.\n\n        The higher the proportion of available outcome tokens for a given outcome,\n        the the lower the price of that token, and therefore the lower the\n        probability of that outcome.\n        \"\"\"\n        if len(self.outcomeTokenAmounts) != 2:\n            raise ValueError(\n                f\"Market with title {self.title} has {len(self.outcomeTokenAmounts)} outcomes.\"\n            )\n\n        if sum(self.outcomeTokenAmounts) == 0:\n            # If there are no outcome tokens, it should mean that market is closed and without liquidity, so we need to infer the probabilities based on the answer.\n            return (\n                Probability(1.0)\n                if self.yes_index == self.answer_index\n                else (\n                    Probability(0.0)\n                    if self.no_index == self.answer_index\n                    else (\n                        Probability(0.5)\n                        if not self.has_valid_answer  # Invalid market or closed market without resolution.\n                        else should_not_happen(\"Unknown condition.\")\n                    )\n                )\n            )\n\n        return Probability(\n            1\n            - (\n                self.outcomeTokenAmounts[self.yes_index]\n                / sum(self.outcomeTokenAmounts, start=OutcomeWei(0))\n            )\n        )\n\n    def __repr__(self) -> str:\n        return f\"Omen's market: {self.title}\"\n\n    @property\n    def is_binary(self) -> bool:\n        return len(self.outcomes) == 2\n\n    def boolean_outcome_from_answer(self, answer: HexBytes) -> bool:\n        if not self.is_binary:\n            raise ValueError(\n                f\"Market with title {self.title} is not binary, it has {len(self.outcomes)} outcomes.\"\n            )\n        outcome: str = self.outcomes[answer.as_int()]\n        return get_boolean_outcome(outcome)\n\n    @property\n    def boolean_outcome(self) -> bool:\n        if not self.is_resolved_with_valid_answer:\n            raise ValueError(f\"Bet with title {self.title} is not resolved.\")\n        return self.boolean_outcome_from_answer(\n            check_not_none(\n                self.currentAnswer, \"Can not be None if `is_resolved_with_valid_answer`\"\n            )\n        )\n\n    def get_resolution_enum_from_answer(self, answer: HexBytes) -> Resolution:\n        if self.boolean_outcome_from_answer(answer):\n            return Resolution.YES\n        else:\n            return Resolution.NO\n\n    def get_resolution_enum(self) -> t.Optional[Resolution]:\n        if not self.is_resolved_with_valid_answer:\n            return None\n        return self.get_resolution_enum_from_answer(\n            check_not_none(\n                self.currentAnswer, \"Can not be None if `is_resolved_with_valid_answer`\"\n            )\n        )\n\n    @property\n    def url(self) -> str:\n        return construct_presagio_url(self.id)\n\n    @staticmethod\n    def from_created_market(model: \"CreatedMarket\") -> \"OmenMarket\":\n        \"\"\"\n        OmenMarket is meant to be retrieved from subgraph, however in tests against local chain it's very handy to create it out of `CreatedMarket`,\n        which is collection of events that are emitted during the market creation in omen_create_market_tx function.\n        \"\"\"\n        if len(model.market_event.conditionIds) != 1:\n            raise ValueError(\n                f\"Unexpected number of conditions: {len(model.market_event.conditionIds)}\"\n            )\n        outcome_token_amounts = model.funding_event.outcome_token_amounts\n        return OmenMarket(\n            id=HexAddress(\n                HexStr(model.market_event.fixedProductMarketMaker.lower())\n            ),  # Lowering to be identical with subgraph's output.\n            title=model.question_event.parsed_question.question,\n            creator=HexAddress(\n                HexStr(model.market_event.creator.lower())\n            ),  # Lowering to be identical with subgraph's output.\n            category=model.question_event.parsed_question.category,\n            collateralVolume=Wei(0),  # No volume possible yet.\n            liquidityParameter=calculate_liquidity_parameter(outcome_token_amounts),\n            usdVolume=USD(0),  # No volume possible yet.\n            fee=model.fee,\n            collateralToken=HexAddress(\n                HexStr(model.market_event.collateralToken.lower())\n            ),  # Lowering to be identical with subgraph's output.\n            outcomes=model.question_event.parsed_question.outcomes,\n            outcomeTokenAmounts=outcome_token_amounts,\n            outcomeTokenMarginalPrices=calculate_marginal_prices(outcome_token_amounts),\n            answerFinalizedTimestamp=None,  # It's a fresh market.\n            currentAnswer=None,  # It's a fresh market.\n            creationTimestamp=model.market_creation_timestamp,\n            condition=Condition(\n                id=model.market_event.conditionIds[0],\n                outcomeSlotCount=len(model.question_event.parsed_question.outcomes),\n            ),\n            question=Question(\n                id=model.question_event.question_id,\n                title=model.question_event.parsed_question.question,\n                data=model.question_event.question,  # Question in the event holds the \"raw\" data.\n                templateId=model.question_event.template_id,\n                outcomes=model.question_event.parsed_question.outcomes,\n                isPendingArbitration=False,  # Can not be, it's a fresh market.\n                openingTimestamp=model.question_event.opening_ts,\n                answerFinalizedTimestamp=None,  # It's a new one, can not be.\n                currentAnswer=None,  # It's a new one, no answer yet.\n            ),\n        )\n\n\nclass OmenCategoricalMarket(OmenMarket):\n    pass\n\n\ndef calculate_liquidity_parameter(\n    outcome_token_amounts: list[OutcomeWei],\n) -> Wei:\n    \"\"\"\n    Converted to Python from https://github.com/protofire/omen-subgraph/blob/f92bbfb6fa31ed9cd5985c416a26a2f640837d8b/src/utils/fpmm.ts#L171.\n    \"\"\"\n    amounts_product = Wei(1)\n    for amount in outcome_token_amounts:\n        amounts_product *= amount.as_wei\n    n = len(outcome_token_amounts)\n    liquidity_parameter = amounts_product.value ** (1.0 / n)\n    return Wei(liquidity_parameter)\n\n\ndef calculate_marginal_prices(\n    outcome_token_amounts: list[OutcomeWei],\n) -> list[CollateralToken] | None:\n    \"\"\"\n    Converted to Python from https://github.com/protofire/omen-subgraph/blob/f92bbfb6fa31ed9cd5985c416a26a2f640837d8b/src/utils/fpmm.ts#L197.\n    \"\"\"\n    all_non_zero = all(x != 0 for x in outcome_token_amounts)\n    if not all_non_zero:\n        return None\n\n    n_outcomes = len(outcome_token_amounts)\n    weights: list[Wei] = []\n\n    for i in range(n_outcomes):\n        weight = Wei(1)\n        for j in range(n_outcomes):\n            if i != j:\n                weight *= outcome_token_amounts[j].as_wei.value\n        weights.append(weight)\n\n    sum_weights = sum(weights, start=Wei(0))\n\n    marginal_prices = [weights[i].value / sum_weights.value for i in range(n_outcomes)]\n    return [CollateralToken(mp) for mp in marginal_prices]\n\n\nclass OmenBetCreator(BaseModel):\n    id: HexAddress\n\n\nclass OmenBet(BaseModel):\n    id: HexAddress  # A concatenation of: FPMM contract ID, trader ID and nonce. See https://github.com/protofire/omen-subgraph/blob/f92bbfb6fa31ed9cd5985c416a26a2f640837d8b/src/FixedProductMarketMakerMapping.ts#L109\n    title: str\n    collateralToken: HexAddress\n    outcomeTokenMarginalPrice: CollateralToken\n    oldOutcomeTokenMarginalPrice: CollateralToken\n    type: str\n    creator: OmenBetCreator\n    creationTimestamp: int\n    collateralAmount: Wei\n    feeAmount: Wei\n    outcomeIndex: int\n    outcomeTokensTraded: OutcomeWei\n    transactionHash: HexBytes\n    fpmm: OmenMarket\n\n    @property\n    def collateral_amount_token(self) -> CollateralToken:\n        return self.collateralAmount.as_token\n\n    @property\n    def collateral_token_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.collateralToken)\n\n    @property\n    def creation_datetime(self) -> DatetimeUTC:\n        return DatetimeUTC.to_datetime_utc(self.creationTimestamp)\n\n    @property\n    def boolean_outcome(self) -> bool:\n        return get_boolean_outcome(self.fpmm.outcomes[self.outcomeIndex])\n\n    @property\n    def old_probability(self) -> Probability:\n        # Old marginal price is the probability of the outcome before placing this bet.\n        return Probability(float(self.oldOutcomeTokenMarginalPrice))\n\n    @property\n    def probability(self) -> Probability:\n        # Marginal price is the probability of the outcome after placing this bet.\n        return Probability(float(self.outcomeTokenMarginalPrice))\n\n    def get_collateral_amount_usd(self) -> USD:\n        return get_token_in_usd(\n            self.collateral_amount_token, self.collateral_token_checksummed\n        )\n\n    def get_profit(self) -> CollateralToken:\n        bet_amount = self.collateral_amount_token\n        profit = (\n            self.outcomeTokensTraded.as_outcome_token.as_token - bet_amount\n            if self.boolean_outcome == self.fpmm.boolean_outcome\n            else -bet_amount\n        )\n        return profit\n\n    def to_bet(self) -> Bet:\n        return Bet(\n            id=str(self.transactionHash),\n            # Use the transaction hash instead of the bet id - both are valid, but we return the transaction hash from the trade functions, so be consistent here.\n            amount=self.collateral_amount_token,\n            outcome=self.boolean_outcome,\n            created_time=self.creation_datetime,\n            market_question=self.title,\n            market_id=self.fpmm.id,\n        )\n\n    def to_generic_resolved_bet(self) -> ResolvedBet:\n        if not self.fpmm.is_resolved_with_valid_answer:\n            raise ValueError(\n                f\"Bet with title {self.title} is not resolved. It has no resolution time.\"\n            )\n\n        return ResolvedBet(\n            id=self.transactionHash.hex(),\n            # Use the transaction hash instead of the bet id - both are valid, but we return the transaction hash from the trade functions, so be consistent here.\n            amount=self.collateral_amount_token,\n            outcome=self.boolean_outcome,\n            created_time=self.creation_datetime,\n            market_question=self.title,\n            market_id=self.fpmm.id,\n            market_outcome=self.fpmm.boolean_outcome,\n            resolved_time=check_not_none(self.fpmm.finalized_datetime),\n            profit=self.get_profit(),\n        )\n\n\nclass FixedProductMarketMakersData(BaseModel):\n    fixedProductMarketMakers: list[OmenMarket]\n\n\nclass FixedProductMarketMakersResponse(BaseModel):\n    data: FixedProductMarketMakersData\n\n\nclass RealityQuestion(BaseModel):\n    # This `id` is in form of `0x79e32ae03fb27b07c89c0c568f80287c01ca2e57-0x2d362f435e7b5159794ff0b5457a900283fca41fe6301dc855a647595903db13`, # web3-private-key-ok\n    # which I couldn't find how it is created, but based on how it looks like I assume it's composed of `answerId-questionId`.\n    # (Why is answer id as part of the question object? Because this question object is actually received from the answer object below).\n    # And because all the contract methods so far needed bytes32 input, when asked for question id, `questionId` field was the correct one to use so far.\n    id: str\n    user: HexAddress\n    historyHash: HexBytes | None\n    updatedTimestamp: int\n    contentHash: HexBytes\n    questionId: HexBytes  # This is the `id` on question from omen subgraph.\n    answerFinalizedTimestamp: int | None\n    currentScheduledFinalizationTimestamp: int\n\n    @property\n    def updated_datetime(self) -> DatetimeUTC:\n        return DatetimeUTC.to_datetime_utc(self.updatedTimestamp)\n\n    @property\n    def answer_finalized_datetime(self) -> DatetimeUTC | None:\n        return (\n            DatetimeUTC.to_datetime_utc(self.answerFinalizedTimestamp)\n            if self.answerFinalizedTimestamp is not None\n            else None\n        )\n\n    @property\n    def current_scheduled_finalization_datetime(self) -> DatetimeUTC:\n        return DatetimeUTC.to_datetime_utc(self.currentScheduledFinalizationTimestamp)\n\n    @property\n    def url(self) -> str:\n        return f\"https://reality.eth.limo/app/#!/question/{self.id}\"\n\n\nclass RealityAnswer(BaseModel):\n    id: str\n    timestamp: int\n    answer: HexBytes\n    lastBond: Wei\n    bondAggregate: Wei\n    question: RealityQuestion\n    createdBlock: int\n\n    @property\n    def timestamp_datetime(self) -> DatetimeUTC:\n        return DatetimeUTC.to_datetime_utc(self.timestamp)\n\n\nclass RealityResponse(BaseModel):\n    \"\"\"\n    This is similar to `RealityAnswer`, but contains additional fields, most importantly `historyHash`.\n    \"\"\"\n\n    id: str\n    timestamp: int\n    answer: HexBytes\n    isUnrevealed: bool\n    isCommitment: bool\n    bond: xDaiWei\n    user: HexAddress\n    historyHash: HexBytes\n    question: RealityQuestion\n    createdBlock: int\n    revealedBlock: int | None\n\n    @property\n    def bond_xdai(self) -> xDai:\n        return self.bond.as_xdai\n\n    @property\n    def user_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.user)\n\n\nclass RealityAnswers(BaseModel):\n    answers: list[RealityAnswer]\n\n\nclass RealityAnswersResponse(BaseModel):\n    data: RealityAnswers\n\n\ndef format_realitio_question(\n    question: str,\n    outcomes: t.Sequence[str],\n    category: str,\n    language: str,\n    template_id: int,\n) -> str:\n    \"\"\"If you add a new template id here, also add to the parsing function below.\"\"\"\n\n    # Escape characters for JSON troubles on Reality.eth.\n    question = question.replace('\"', '\\\\\"')\n\n    if template_id == 2:\n        return \"␟\".join(\n            [\n                question,\n                \",\".join(f'\"{o}\"' for o in outcomes),\n                category,\n                language,\n            ]\n        )\n\n    raise ValueError(f\"Unsupported template id {template_id}.\")\n\n\ndef parse_realitio_question(question_raw: str, template_id: int) -> \"ParsedQuestion\":\n    \"\"\"If you add a new template id here, also add to the encoding function above.\"\"\"\n    if template_id == 2:\n        question, outcomes_raw, category, language = question_raw.split(\"␟\")\n        outcomes = [OutcomeStr(o.strip('\"')) for o in outcomes_raw.split(\",\")]\n        return ParsedQuestion(\n            question=question, outcomes=outcomes, category=category, language=language\n        )\n\n    raise ValueError(f\"Unsupported template id {template_id}.\")\n\n\nclass ParsedQuestion(BaseModel):\n    question: str\n    outcomes: t.Sequence[OutcomeStr]\n    language: str\n    category: str\n\n\nclass RealitioLogNewQuestionEvent(BaseModel):\n    question_id: HexBytes\n    user: HexAddress\n    template_id: int\n    question: str  # Be aware, this is question in format of format_realitio_question function, it's raw data.\n    content_hash: HexBytes\n    arbitrator: HexAddress\n    timeout: int\n    opening_ts: int\n    nonce: int\n    created: int\n\n    @property\n    def user_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.user)\n\n    @property\n    def parsed_question(self) -> ParsedQuestion:\n        return parse_realitio_question(\n            question_raw=self.question, template_id=self.template_id\n        )\n\n\nclass OmenFixedProductMarketMakerCreationEvent(BaseModel):\n    creator: HexAddress\n    fixedProductMarketMaker: HexAddress\n    conditionalTokens: HexAddress\n    collateralToken: HexAddress\n    conditionIds: list[HexBytes]\n    fee: int\n\n    @property\n    def creator_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.creator)\n\n    @property\n    def fixed_product_market_maker_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.fixedProductMarketMaker)\n\n    @property\n    def conditional_tokens_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.conditionalTokens)\n\n    @property\n    def collateral_token_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.collateralToken)\n\n\nclass ConditionPreparationEvent(BaseModel):\n    conditionId: HexBytes\n    oracle: HexAddress\n    questionId: HexBytes\n    outcomeSlotCount: int\n\n\nclass FPMMFundingAddedEvent(BaseModel):\n    funder: HexAddress\n    amountsAdded: list[Wei]\n    sharesMinted: Wei\n\n    @property\n    def outcome_token_amounts(self) -> list[OutcomeWei]:\n        # Just renaming so we remember what it is.\n        return [OutcomeWei(x.value) for x in self.amountsAdded]\n\n\nclass CreatedMarket(BaseModel):\n    market_creation_timestamp: int\n    market_event: OmenFixedProductMarketMakerCreationEvent\n    funding_event: FPMMFundingAddedEvent\n    condition_id: HexBytes\n    question_event: RealitioLogNewQuestionEvent\n    condition_event: ConditionPreparationEvent | None\n    initial_funds: Wei\n    fee: Wei\n    distribution_hint: list[OutcomeWei] | None\n\n    @property\n    def url(self) -> str:\n        return construct_presagio_url(\n            self.market_event.fixed_product_market_maker_checksummed\n        )\n\n\nclass ContractPrediction(BaseModel):\n    model_config = ConfigDict(populate_by_name=True)\n    publisher: str = Field(..., alias=\"publisherAddress\")\n    ipfs_hash: HexBytes = Field(..., alias=\"ipfsHash\")\n    tx_hashes: list[HexBytes] = Field(..., alias=\"txHashes\")\n    estimated_probability_bps: int = Field(..., alias=\"estimatedProbabilityBps\")\n\n    @property\n    def estimated_probability(self) -> Probability:\n        return Probability(self.estimated_probability_bps / BPS_CONSTANT)\n\n    @property\n    def boolean_outcome(self) -> bool:\n        return self.estimated_probability > 0.5\n\n    @computed_field  # type: ignore[prop-decorator] # Mypy issue: https://github.com/python/mypy/issues/14461\n    @property\n    def publisher_checksummed(self) -> ChecksumAddress:\n        return Web3.to_checksum_address(self.publisher)\n\n    @staticmethod\n    def from_tuple(values: tuple[t.Any, ...]) -> \"ContractPrediction\":\n        return ContractPrediction(\n            publisher=values[0],\n            ipfs_hash=values[1],\n            tx_hashes=values[2],\n            estimated_probability_bps=values[3],\n        )\n\n\nclass IPFSAgentResult(BaseModel):\n    reasoning: str\n    agent_name: str\n    model_config = ConfigDict(\n        extra=\"forbid\",\n    )\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/prediction_market_agent_tooling/markets/omen/data_models.py b/prediction_market_agent_tooling/markets/omen/data_models.py
--- a/prediction_market_agent_tooling/markets/omen/data_models.py	(revision a6ddfe6af5cc2d1e1834b5c37a39e24927342d0c)
+++ b/prediction_market_agent_tooling/markets/omen/data_models.py	(date 1745434479399)
@@ -399,26 +399,15 @@
     def is_binary(self) -> bool:
         return len(self.outcomes) == 2
 
-    def boolean_outcome_from_answer(self, answer: HexBytes) -> bool:
+    def outcome_from_answer(self, answer: HexBytes) -> OutcomeStr:
         if not self.is_binary:
             raise ValueError(
                 f"Market with title {self.title} is not binary, it has {len(self.outcomes)} outcomes."
             )
-        outcome: str = self.outcomes[answer.as_int()]
-        return get_boolean_outcome(outcome)
-
-    @property
-    def boolean_outcome(self) -> bool:
-        if not self.is_resolved_with_valid_answer:
-            raise ValueError(f"Bet with title {self.title} is not resolved.")
-        return self.boolean_outcome_from_answer(
-            check_not_none(
-                self.currentAnswer, "Can not be None if `is_resolved_with_valid_answer`"
-            )
-        )
+        return self.outcomes[answer.as_int()]
 
     def get_resolution_enum_from_answer(self, answer: HexBytes) -> Resolution:
-        if self.boolean_outcome_from_answer(answer):
+        if self.outcome_from_answer(answer):
             return Resolution.YES
         else:
             return Resolution.NO
@@ -563,10 +552,6 @@
     def creation_datetime(self) -> DatetimeUTC:
         return DatetimeUTC.to_datetime_utc(self.creationTimestamp)
 
-    @property
-    def boolean_outcome(self) -> bool:
-        return get_boolean_outcome(self.fpmm.outcomes[self.outcomeIndex])
-
     @property
     def old_probability(self) -> Probability:
         # Old marginal price is the probability of the outcome before placing this bet.
@@ -584,9 +569,14 @@
 
     def get_profit(self) -> CollateralToken:
         bet_amount = self.collateral_amount_token
+        # ToDo - Check if resolved
+
+        if not self.fpmm.has_valid_answer:
+            return CollateralToken(0)
+
         profit = (
             self.outcomeTokensTraded.as_outcome_token.as_token - bet_amount
-            if self.boolean_outcome == self.fpmm.boolean_outcome
+            if self.outcomeIndex == self.fpmm.answer_index
             else -bet_amount
         )
         return profit
@@ -596,7 +586,7 @@
             id=str(self.transactionHash),
             # Use the transaction hash instead of the bet id - both are valid, but we return the transaction hash from the trade functions, so be consistent here.
             amount=self.collateral_amount_token,
-            outcome=self.boolean_outcome,
+            outcome=self.fpmm.outcomes[self.outcomeIndex],
             created_time=self.creation_datetime,
             market_question=self.title,
             market_id=self.fpmm.id,
@@ -612,11 +602,11 @@
             id=self.transactionHash.hex(),
             # Use the transaction hash instead of the bet id - both are valid, but we return the transaction hash from the trade functions, so be consistent here.
             amount=self.collateral_amount_token,
-            outcome=self.boolean_outcome,
+            outcome=self.fpmm.outcomes[self.outcomeIndex],
             created_time=self.creation_datetime,
             market_question=self.title,
             market_id=self.fpmm.id,
-            market_outcome=self.fpmm.boolean_outcome,
+            market_outcome=self.fpmm.outcomes[self.outcomeIndex],
             resolved_time=check_not_none(self.fpmm.finalized_datetime),
             profit=self.get_profit(),
         )
