Index: prediction_market_agent_tooling/markets/seer/price_manager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from functools import lru_cache\n\nfrom web3 import Web3\n\nfrom prediction_market_agent_tooling.gtypes import (\n    ChecksumAddress,\n    CollateralToken,\n    Probability,\n    USD,\n)\nfrom prediction_market_agent_tooling.loggers import logger\nfrom prediction_market_agent_tooling.markets.seer.data_models import (\n    SeerMarket,\n    SeerOutcomeEnum,\n)\nfrom prediction_market_agent_tooling.markets.seer.seer_subgraph_handler import (\n    SeerSubgraphHandler,\n)\nfrom prediction_market_agent_tooling.markets.seer.subgraph_data_models import SeerPool\nfrom prediction_market_agent_tooling.tools.cow.cow_order import (\n    get_buy_token_amount_else_raise,\n)\nfrom prediction_market_agent_tooling.tools.hexbytes_custom import HexBytes\nfrom prediction_market_agent_tooling.tools.tokens.usd import (\n    get_single_token_to_usd_rate,\n)\n\n\nclass PriceManager:\n    def __init__(self, seer_market: SeerMarket, seer_subgraph: SeerSubgraphHandler):\n        self.seer_market = seer_market\n        self.seer_subgraph = seer_subgraph\n\n    @staticmethod\n    def build(market_id: HexBytes) -> \"PriceManager\":\n        s = SeerSubgraphHandler()\n        market = s.get_market_by_id(market_id=market_id)\n        return PriceManager(seer_market=market, seer_subgraph=s)\n\n    def _log_track_price_normalization_diff(\n        self, old_price: float, normalized_price: float, max_price_diff: float = 0.05\n    ) -> None:\n        # We add max(price,0.01) to avoid division by 0\n        price_diff_pct = abs(old_price - normalized_price) / max(old_price, 0.01)\n        if price_diff_pct > max_price_diff:\n            logger.info(\n                f\"{price_diff_pct=} larger than {max_price_diff=} for seer market {self.seer_market.id.hex()} \"\n            )\n\n    def current_p_yes(self) -> Probability | None:\n        # Inspired by https://github.com/seer-pm/demo/blob/ca682153a6b4d4dd3dcc4ad8bdcbe32202fc8fe7/web/src/hooks/useMarketOdds.ts#L15\n        price_data: dict[int, CollateralToken | None] = {}\n        for idx, wrapped_token in enumerate(self.seer_market.wrapped_tokens):\n            price = self.get_price_for_token(\n                token=Web3.to_checksum_address(wrapped_token),\n            )\n\n            price_data[idx] = price\n\n        price_yes = price_data[self.seer_market.outcome_as_enums[SeerOutcomeEnum.YES]]\n        price_no = price_data[self.seer_market.outcome_as_enums[SeerOutcomeEnum.NO]]\n\n        # We only return a probability if we have both price_yes and price_no, since we could place bets\n        # in both sides hence we need current probabilities for both outcomes.\n        if price_yes is not None and price_no is not None:\n            normalized_price_yes = price_yes / (price_yes + price_no)\n            self._log_track_price_normalization_diff(\n                old_price=price_yes.value, normalized_price=normalized_price_yes\n            )\n            return Probability(normalized_price_yes)\n        else:\n            return None\n\n    @lru_cache\n    def get_price_for_token(\n        self,\n        token: ChecksumAddress,\n        collateral_exchange_amount: CollateralToken | None = None,\n    ) -> CollateralToken | None:\n        collateral_exchange_amount = (\n            collateral_exchange_amount\n            if collateral_exchange_amount is not None\n            else CollateralToken(1)\n        )\n\n        try:\n            buy_token_amount = get_buy_token_amount_else_raise(\n                amount_wei=collateral_exchange_amount.as_wei,\n                sell_token=self.seer_market.collateral_token_contract_address_checksummed,\n                buy_token=token,\n            )\n            price = collateral_exchange_amount.as_wei / buy_token_amount\n            return CollateralToken(price)\n\n        except Exception as e:\n            logger.warning(\n                f\"Could not get quote for {token=} from Cow, exception {e=}. Falling back to pools. \"\n            )\n            return self.get_token_price_from_pools(token=token)\n\n    @staticmethod\n    def _pool_token0_matches_token(token: ChecksumAddress, pool: SeerPool) -> bool:\n        return pool.token0.id.hex().lower() == token.lower()\n\n    def get_token_price_from_pools(\n        self,\n        token: ChecksumAddress,\n    ) -> CollateralToken | None:\n        pool = SeerSubgraphHandler().get_pool_by_token(\n            token_address=token,\n            collateral_address=self.seer_market.collateral_token_contract_address_checksummed,\n        )\n\n        if not pool:\n            logger.warning(f\"Could not find a pool for {token=}\")\n            return None\n\n        # The mapping below is odd but surprisingly the Algebra subgraph delivers the token1Price\n        # for the token0 and the token0Price for the token1 pool.\n        # For example, in a outcomeYES (token0)/sDAI pool (token1), token1Price is the price of outcomeYES in units of sDAI.\n        price = (\n            pool.token1Price\n            if self._pool_token0_matches_token(token=token, pool=pool)\n            else pool.token0Price\n        )\n        return price\n\n    def get_liquidity_usd_from_market(self) -> USD:\n        sdai_price_usd = get_single_token_to_usd_rate(\n            token_address=self.seer_market.collateral_token_contract_address_checksummed\n        )\n        liquidity_collateral_units = CollateralToken(0)\n        for token in self.seer_market.wrapped_tokens:\n            token_checksummed = Web3.to_checksum_address(token)\n            pool = self.seer_subgraph.get_pool_by_token(\n                token_address=token_checksummed,\n                collateral_address=self.seer_market.collateral_token_contract_address_checksummed,\n            )\n            if not pool:\n                continue\n            # find collateral\n            if self._pool_token0_matches_token(token=token_checksummed, pool=pool):\n                liquidity_collateral_units += (\n                    pool.totalValueLockedToken0 * pool.token0Price\n                    + pool.totalValueLockedToken1\n                )\n            else:\n                liquidity_collateral_units += (\n                    pool.totalValueLockedToken1 * pool.token1Price\n                    + pool.totalValueLockedToken0\n                )\n        liquidity_usd = liquidity_collateral_units * sdai_price_usd\n        return liquidity_usd\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/prediction_market_agent_tooling/markets/seer/price_manager.py b/prediction_market_agent_tooling/markets/seer/price_manager.py
--- a/prediction_market_agent_tooling/markets/seer/price_manager.py	(revision df193bc64eb9546135e3df7faf33de60a10d2744)
+++ b/prediction_market_agent_tooling/markets/seer/price_manager.py	(date 1743687395215)
@@ -1,12 +1,11 @@
-from functools import lru_cache
-
+from cachetools import TTLCache, cached
 from web3 import Web3
 
 from prediction_market_agent_tooling.gtypes import (
+    USD,
     ChecksumAddress,
     CollateralToken,
     Probability,
-    USD,
 )
 from prediction_market_agent_tooling.loggers import logger
 from prediction_market_agent_tooling.markets.seer.data_models import (
@@ -71,7 +70,7 @@
         else:
             return None
 
-    @lru_cache
+    @cached(TTLCache(maxsize=100, ttl=5 * 60))
     def get_price_for_token(
         self,
         token: ChecksumAddress,
@@ -85,7 +84,7 @@
 
         try:
             buy_token_amount = get_buy_token_amount_else_raise(
-                amount_wei=collateral_exchange_amount.as_wei,
+                sell_amount=collateral_exchange_amount.as_wei,
                 sell_token=self.seer_market.collateral_token_contract_address_checksummed,
                 buy_token=token,
             )
Index: tests_integration_with_local_chain/tools/test_cow_order.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nimport pytest\nfrom web3 import Web3\n\nfrom prediction_market_agent_tooling.config import APIKeys\nfrom prediction_market_agent_tooling.gtypes import ChecksumAddress, CollateralToken\nfrom prediction_market_agent_tooling.markets.omen.omen_contracts import (\n    GNOContract,\n    WrappedxDaiContract,\n    sDaiContract,\n)\nfrom prediction_market_agent_tooling.tools.cow.cow_order import (\n    get_buy_token_amount_else_raise,\n    get_sell_token_amount,\n    swap_tokens_waiting,\n)\n\n\n@pytest.mark.skip(\"Cow integration still in progress\")\ndef test_get_buy_token_amount() -> None:\n    sell_amount = CollateralToken(0.1).as_wei\n    buy_amount = get_buy_token_amount_else_raise(\n        amount_wei=sell_amount,\n        sell_token=WrappedxDaiContract().address,\n        buy_token=sDaiContract().address,\n    )\n    assert (\n        buy_amount < sell_amount\n    ), f\"sDai should be more expensive than wxDai, but {buy_amount} >= {sell_amount}\"\n\n\n@pytest.mark.skip(\"Cow integration still in progress\")\n@pytest.mark.parametrize(\n    \"sell_token, buy_token\",\n    [\n        (WrappedxDaiContract().address, sDaiContract().address),\n        (sDaiContract().address, WrappedxDaiContract().address),\n        (GNOContract().address, WrappedxDaiContract().address),\n    ],\n)\ndef test_get_buy_vs_sell_token_amount(\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n) -> None:\n    wanted_in_buying_token = CollateralToken(10)\n    calculated_how_much_do_i_need_to_sell = get_sell_token_amount(\n        buy_amount=wanted_in_buying_token.as_wei,\n        sell_token=sell_token,\n        buy_token=buy_token,\n    )\n    how_much_would_i_get_from_calculated = get_buy_token_amount_else_raise(\n        amount_wei=calculated_how_much_do_i_need_to_sell,\n        sell_token=sell_token,\n        buy_token=buy_token,\n    )\n    assert np.isclose(\n        wanted_in_buying_token.value,\n        how_much_would_i_get_from_calculated.as_token.value,\n        rtol=0.01,\n    )\n\n\n@pytest.mark.skip(\"Cow integration still in progress\")\n@pytest.mark.parametrize(\n    \"sell_token, buy_token\",\n    [\n        (WrappedxDaiContract().address, sDaiContract().address),\n        (sDaiContract().address, WrappedxDaiContract().address),\n        (GNOContract().address, WrappedxDaiContract().address),\n    ],\n)\ndef test_swap_tokens_waiting(\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n    local_web3: Web3,\n    test_keys: APIKeys,\n) -> None:\n    with pytest.raises(Exception) as e:\n        swap_tokens_waiting(\n            amount_wei=CollateralToken(1).as_wei,\n            sell_token=sell_token,\n            buy_token=buy_token,\n            api_keys=test_keys,\n            web3=local_web3,\n        )\n    # This is raised in `post_order` which is last call when swapping tokens, anvil's accounts don't have any balance on real chain, so this is expected,\n    # but still, it tests that all the logic behind calling CoW APIs is working correctly.\n    assert \"InsufficientBalance\" in str(e)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests_integration_with_local_chain/tools/test_cow_order.py b/tests_integration_with_local_chain/tools/test_cow_order.py
--- a/tests_integration_with_local_chain/tools/test_cow_order.py	(revision df193bc64eb9546135e3df7faf33de60a10d2744)
+++ b/tests_integration_with_local_chain/tools/test_cow_order.py	(date 1743687238191)
@@ -20,7 +20,7 @@
 def test_get_buy_token_amount() -> None:
     sell_amount = CollateralToken(0.1).as_wei
     buy_amount = get_buy_token_amount_else_raise(
-        amount_wei=sell_amount,
+        sell_amount=sell_amount,
         sell_token=WrappedxDaiContract().address,
         buy_token=sDaiContract().address,
     )
@@ -49,7 +49,7 @@
         buy_token=buy_token,
     )
     how_much_would_i_get_from_calculated = get_buy_token_amount_else_raise(
-        amount_wei=calculated_how_much_do_i_need_to_sell,
+        sell_amount=calculated_how_much_do_i_need_to_sell,
         sell_token=sell_token,
         buy_token=buy_token,
     )
Index: prediction_market_agent_tooling/tools/cow/cow_order.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio\nfrom datetime import timedelta\n\nimport httpx\nimport tenacity\nfrom cowdao_cowpy import swap_tokens\nfrom cowdao_cowpy.common.api.errors import UnexpectedResponseError\nfrom cowdao_cowpy.common.chains import Chain\nfrom cowdao_cowpy.common.config import SupportedChainId\nfrom cowdao_cowpy.common.constants import CowContractAddress\nfrom cowdao_cowpy.cow.swap import get_order_quote\nfrom cowdao_cowpy.order_book.api import OrderBookApi\nfrom cowdao_cowpy.order_book.config import Envs, OrderBookAPIConfigFactory\nfrom cowdao_cowpy.order_book.generated.model import (\n    Address,\n    OrderMetaData,\n    OrderQuoteRequest,\n    OrderQuoteResponse,\n    OrderQuoteSide1,\n    OrderQuoteSide3,\n    OrderQuoteSideKindBuy,\n    OrderQuoteSideKindSell,\n    OrderStatus,\n    TokenAmount,\n)\nfrom eth_account.signers.local import LocalAccount\nfrom tenacity import retry_if_not_exception_type, stop_after_attempt, wait_fixed\nfrom web3 import Web3\n\nfrom prediction_market_agent_tooling.config import APIKeys\nfrom prediction_market_agent_tooling.gtypes import ChecksumAddress, Wei\nfrom prediction_market_agent_tooling.loggers import logger\nfrom prediction_market_agent_tooling.tools.contract import ContractERC20OnGnosisChain\nfrom prediction_market_agent_tooling.tools.utils import utcnow\n\n\nclass OrderStatusError(Exception):\n    pass\n\n\nclass NoLiquidityAvailableOnCowException(Exception):\n    \"\"\"Custom exception for handling case where no liquidity available.\"\"\"\n\n\ndef get_order_book_api(env: Envs, chain: Chain) -> OrderBookApi:\n    chain_id = SupportedChainId(chain.value[0])\n    return OrderBookApi(OrderBookAPIConfigFactory.get_config(env, chain_id))\n\n\n@tenacity.retry(\n    stop=tenacity.stop_after_attempt(3),\n    wait=tenacity.wait_fixed(1),\n    after=lambda x: logger.debug(f\"get_sell_token_amount failed, {x.attempt_number=}.\"),\n)\ndef get_sell_token_amount(\n    buy_amount: Wei,\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n    chain: Chain = Chain.GNOSIS,\n    env: Envs = \"prod\",\n) -> Wei:\n    \"\"\"\n    Calculate how much of the sell_token is needed to obtain a specified amount of buy_token.\n    \"\"\"\n    order_book_api = get_order_book_api(env, chain)\n    order_quote_request = OrderQuoteRequest(\n        sellToken=Address(sell_token),\n        buyToken=Address(buy_token),\n        from_=Address(\n            \"0x1234567890abcdef1234567890abcdef12345678\"\n        ),  # Just random address, doesn't matter.\n    )\n    order_side = OrderQuoteSide3(\n        kind=OrderQuoteSideKindBuy.buy,\n        buyAmountAfterFee=TokenAmount(str(buy_amount)),\n    )\n    order_quote = asyncio.run(\n        order_book_api.post_quote(order_quote_request, order_side)\n    )\n    return Wei(order_quote.quote.sellAmount.root)\n\n\n@tenacity.retry(\n    stop=stop_after_attempt(3),\n    wait=wait_fixed(1),\n    retry=retry_if_not_exception_type(NoLiquidityAvailableOnCowException),\n)\ndef get_quote(\n    amount_wei: Wei,\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n    chain: Chain = Chain.GNOSIS,\n    env: Envs = \"prod\",\n) -> OrderQuoteResponse:\n    order_book_api = get_order_book_api(env, chain)\n    order_quote_request = OrderQuoteRequest(\n        sellToken=Address(sell_token),\n        buyToken=Address(buy_token),\n        from_=Address(\n            \"0x1234567890abcdef1234567890abcdef12345678\"\n        ),  # Just random address, doesn't matter.\n    )\n    order_side = OrderQuoteSide1(\n        kind=OrderQuoteSideKindSell.sell,\n        sellAmountBeforeFee=TokenAmount(str(amount_wei)),\n    )\n\n    try:\n        order_quote = asyncio.run(\n            get_order_quote(\n                order_quote_request=order_quote_request,\n                order_side=order_side,\n                order_book_api=order_book_api,\n            )\n        )\n\n        return order_quote\n\n    except UnexpectedResponseError as e1:\n        if \"NoLiquidity\" in e1.message:\n            raise NoLiquidityAvailableOnCowException(e1.message)\n        logger.warning(f\"Found unexpected Cow response error: {e1}\")\n        raise\n    except Exception as e:\n        logger.warning(f\"Found unhandled Cow response error: {e}\")\n        raise\n\n\ndef get_buy_token_amount_else_raise(\n    amount_wei: Wei,\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n    chain: Chain = Chain.GNOSIS,\n    env: Envs = \"prod\",\n) -> Wei:\n    order_quote = get_quote(\n        amount_wei=amount_wei,\n        sell_token=sell_token,\n        buy_token=buy_token,\n        chain=chain,\n        env=env,\n    )\n    return Wei(order_quote.quote.buyAmount.root)\n\n\n@tenacity.retry(\n    stop=stop_after_attempt(3),\n    wait=wait_fixed(1),\n    retry=tenacity.retry_if_not_exception_type((TimeoutError, OrderStatusError)),\n    after=lambda x: logger.debug(f\"swap_tokens_waiting failed, {x.attempt_number=}.\"),\n)\ndef swap_tokens_waiting(\n    amount_wei: Wei,\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n    api_keys: APIKeys,\n    chain: Chain = Chain.GNOSIS,\n    env: Envs = \"prod\",\n    web3: Web3 | None = None,\n) -> OrderMetaData:\n    account = api_keys.get_account()\n\n    # Approve the CoW Swap Vault Relayer to get the sell token.\n    ContractERC20OnGnosisChain(address=sell_token).approve(\n        api_keys,\n        Web3.to_checksum_address(CowContractAddress.VAULT_RELAYER.value),\n        amount_wei=amount_wei,\n        web3=web3,\n    )\n\n    # CoW library uses async, so we need to wrap the call in asyncio.run for us to use it.\n    return asyncio.run(\n        swap_tokens_waiting_async(\n            amount_wei, sell_token, buy_token, account, chain, env\n        )\n    )\n\n\nasync def swap_tokens_waiting_async(\n    amount_wei: Wei,\n    sell_token: ChecksumAddress,\n    buy_token: ChecksumAddress,\n    account: LocalAccount,\n    chain: Chain,\n    env: Envs,\n    timeout: timedelta = timedelta(seconds=60),\n) -> OrderMetaData:\n    order = await swap_tokens(\n        amount=amount_wei.value,\n        sell_token=sell_token,\n        buy_token=buy_token,\n        account=account,\n        chain=chain,\n        env=env,\n    )\n    logger.info(f\"Order created: {order}\")\n    start_time = utcnow()\n\n    while True:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(order.url)\n            order_metadata = OrderMetaData.model_validate(response.json())\n\n        if order_metadata.status == OrderStatus.fulfilled:\n            logger.info(f\"Order {order.uid} ({order.url}) completed.\")\n            return order_metadata\n\n        elif order_metadata.status in (\n            OrderStatus.cancelled,\n            OrderStatus.expired,\n        ):\n            raise OrderStatusError(f\"Order {order.uid} failed. {order.url}\")\n\n        if utcnow() - start_time > timeout:\n            raise TimeoutError(\n                f\"Timeout waiting for order {order.uid} to be completed. {order.url}\"\n            )\n\n        logger.info(\n            f\"Order status of {order.uid} ({order.url}): {order_metadata.status}, waiting...\"\n        )\n\n        await asyncio.sleep(3.14)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/prediction_market_agent_tooling/tools/cow/cow_order.py b/prediction_market_agent_tooling/tools/cow/cow_order.py
--- a/prediction_market_agent_tooling/tools/cow/cow_order.py	(revision df193bc64eb9546135e3df7faf33de60a10d2744)
+++ b/prediction_market_agent_tooling/tools/cow/cow_order.py	(date 1743687238204)
@@ -127,14 +127,14 @@
 
 
 def get_buy_token_amount_else_raise(
-    amount_wei: Wei,
+    sell_amount: Wei,
     sell_token: ChecksumAddress,
     buy_token: ChecksumAddress,
     chain: Chain = Chain.GNOSIS,
     env: Envs = "prod",
 ) -> Wei:
     order_quote = get_quote(
-        amount_wei=amount_wei,
+        amount_wei=sell_amount,
         sell_token=sell_token,
         buy_token=buy_token,
         chain=chain,
Index: prediction_market_agent_tooling/markets/seer/seer.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import typing as t\n\nfrom eth_pydantic_types import HexStr\nfrom eth_typing import ChecksumAddress\nfrom web3 import Web3\nfrom web3.types import TxReceipt\n\nfrom prediction_market_agent_tooling.config import APIKeys, RPCConfig\nfrom prediction_market_agent_tooling.gtypes import (\n    USD,\n    CollateralToken,\n    HexAddress,\n    HexBytes,\n    OutcomeStr,\n    OutcomeToken,\n    OutcomeWei,\n    xDai,\n)\nfrom prediction_market_agent_tooling.loggers import logger\nfrom prediction_market_agent_tooling.markets.agent_market import (\n    AgentMarket,\n    FilterBy,\n    ProcessedMarket,\n    ProcessedTradedMarket,\n    SortBy,\n)\nfrom prediction_market_agent_tooling.markets.data_models import ExistingPosition\nfrom prediction_market_agent_tooling.markets.market_fees import MarketFees\nfrom prediction_market_agent_tooling.markets.omen.omen import OmenAgentMarket\nfrom prediction_market_agent_tooling.markets.seer.data_models import (\n    SeerMarket,\n    SeerOutcomeEnum,\n)\nfrom prediction_market_agent_tooling.markets.seer.price_manager import PriceManager\nfrom prediction_market_agent_tooling.markets.seer.seer_contracts import (\n    SeerMarketFactory,\n)\nfrom prediction_market_agent_tooling.markets.seer.seer_subgraph_handler import (\n    SeerSubgraphHandler,\n)\nfrom prediction_market_agent_tooling.markets.seer.subgraph_data_models import (\n    NewMarketEvent,\n)\nfrom prediction_market_agent_tooling.tools.contract import (\n    ContractERC20OnGnosisChain,\n    init_collateral_token_contract,\n    to_gnosis_chain_contract,\n)\nfrom prediction_market_agent_tooling.tools.cow.cow_order import (\n    get_buy_token_amount_else_raise,\n    swap_tokens_waiting,\n)\nfrom prediction_market_agent_tooling.tools.datetime_utc import DatetimeUTC\nfrom prediction_market_agent_tooling.tools.tokens.auto_deposit import (\n    auto_deposit_collateral_token,\n)\nfrom prediction_market_agent_tooling.tools.tokens.usd import (\n    get_token_in_usd,\n    get_usd_in_token,\n)\n\n# We place a larger bet amount by default than Omen so that cow presents valid quotes.\nSEER_TINY_BET_AMOUNT = USD(0.1)\n\n\nclass SeerAgentMarket(AgentMarket):\n    wrapped_tokens: list[ChecksumAddress]\n    creator: HexAddress\n    collateral_token_contract_address_checksummed: ChecksumAddress\n    condition_id: HexBytes\n    seer_outcomes: dict[SeerOutcomeEnum, int]\n    description: str | None = (\n        None  # Seer markets don't have a description, so just default to None.\n    )\n\n    def get_collateral_token_contract(\n        self, web3: Web3 | None = None\n    ) -> ContractERC20OnGnosisChain:\n        web3 = web3 or RPCConfig().get_web3()\n        return to_gnosis_chain_contract(\n            init_collateral_token_contract(\n                self.collateral_token_contract_address_checksummed, web3\n            )\n        )\n\n    def store_prediction(\n        self,\n        processed_market: ProcessedMarket | None,\n        keys: APIKeys,\n        agent_name: str,\n    ) -> None:\n        \"\"\"On Seer, we have to store predictions along with trades, see `store_trades`.\"\"\"\n\n    def store_trades(\n        self,\n        traded_market: ProcessedTradedMarket | None,\n        keys: APIKeys,\n        agent_name: str,\n        web3: Web3 | None = None,\n    ) -> None:\n        pass\n\n    def get_token_in_usd(self, x: CollateralToken) -> USD:\n        return get_token_in_usd(x, self.collateral_token_contract_address_checksummed)\n\n    def get_usd_in_token(self, x: USD) -> CollateralToken:\n        return get_usd_in_token(x, self.collateral_token_contract_address_checksummed)\n\n    def get_buy_token_amount(\n        self, bet_amount: USD | CollateralToken, direction: bool\n    ) -> OutcomeToken | None:\n        \"\"\"Returns number of outcome tokens returned for a given bet expressed in collateral units.\"\"\"\n\n        outcome_token = self.get_wrapped_token_for_outcome(direction)\n        bet_amount_in_tokens = self.get_in_token(bet_amount)\n\n        p = PriceManager.build(market_id=HexBytes(HexStr(self.id)))\n        price = p.get_price_for_token(\n            token=outcome_token, collateral_exchange_amount=bet_amount_in_tokens\n        )\n        if not price:\n            logger.info(f\"Could not get price for token {outcome_token}\")\n            return None\n\n        amount_outcome_tokens = bet_amount_in_tokens / price\n        return OutcomeToken(amount_outcome_tokens)\n\n    def get_sell_value_of_outcome_token(\n        self, outcome: str, amount: OutcomeToken\n    ) -> CollateralToken:\n        if amount == amount.zero():\n            return CollateralToken.zero()\n\n        outcome_index = self.get_outcome_index(outcome=outcome)\n        wrapped_outcome_token = self.wrapped_tokens[outcome_index]\n\n        # We calculate how much collateral we would get back if we sold `amount` of outcome token.\n\n        value_outcome_token_in_collateral = get_buy_token_amount_else_raise(\n            amount_wei=amount.as_outcome_wei.as_wei,\n            sell_token=wrapped_outcome_token,\n            buy_token=self.collateral_token_contract_address_checksummed,\n        )\n        return value_outcome_token_in_collateral.as_token\n\n    def get_outcome_str_from_bool(self, outcome: bool) -> OutcomeStr:\n        outcome_translated = SeerOutcomeEnum.from_bool(outcome)\n        idx = self.seer_outcomes[outcome_translated]\n        return OutcomeStr(self.outcomes[idx])\n\n    @staticmethod\n    def get_trade_balance(api_keys: APIKeys) -> USD:\n        return OmenAgentMarket.get_trade_balance(api_keys=api_keys)\n\n    def get_tiny_bet_amount(self) -> CollateralToken:\n        return self.get_in_token(SEER_TINY_BET_AMOUNT)\n\n    def get_position_else_raise(\n        self, user_id: str, web3: Web3 | None = None\n    ) -> ExistingPosition:\n        \"\"\"\n        Fetches position from the user in a given market.\n        We ignore the INVALID balances since we are only interested in binary outcomes.\n        \"\"\"\n\n        amounts_ot: dict[OutcomeStr, OutcomeToken] = {}\n\n        for outcome in [True, False]:\n            wrapped_token = self.get_wrapped_token_for_outcome(outcome)\n\n            outcome_token_balance_wei = OutcomeWei.from_wei(\n                ContractERC20OnGnosisChain(address=wrapped_token).balanceOf(\n                    for_address=Web3.to_checksum_address(user_id), web3=web3\n                )\n            )\n            outcome_str = self.get_outcome_str_from_bool(outcome=outcome)\n            amounts_ot[outcome_str] = outcome_token_balance_wei.as_outcome_token\n\n        amounts_current = {\n            k: self.get_token_in_usd(self.get_sell_value_of_outcome_token(k, v))\n            for k, v in amounts_ot.items()\n        }\n        amounts_potential = {\n            k: self.get_token_in_usd(v.as_token) for k, v in amounts_ot.items()\n        }\n        return ExistingPosition(\n            market_id=self.id,\n            amounts_current=amounts_current,\n            amounts_potential=amounts_potential,\n            amounts_ot=amounts_ot,\n        )\n\n    def get_position(\n        self, user_id: str, web3: Web3 | None = None\n    ) -> ExistingPosition | None:\n        try:\n            return self.get_position_else_raise(user_id=user_id, web3=web3)\n        except Exception:\n            logger.info(f\"Could not get position for user {user_id}\")\n            return None\n\n    @staticmethod\n    def get_user_id(api_keys: APIKeys) -> str:\n        return OmenAgentMarket.get_user_id(api_keys)\n\n    @staticmethod\n    def redeem_winnings(api_keys: APIKeys) -> None:\n        # ToDo - implement me (https://github.com/gnosis/prediction-market-agent-tooling/issues/499)\n        pass\n\n    @staticmethod\n    def verify_operational_balance(api_keys: APIKeys) -> bool:\n        return OmenAgentMarket.verify_operational_balance(api_keys=api_keys)\n\n    @staticmethod\n    def from_data_model_with_subgraph(\n        model: SeerMarket, seer_subgraph: SeerSubgraphHandler\n    ) -> t.Optional[\"SeerAgentMarket\"]:\n        p = PriceManager(seer_market=model, seer_subgraph=seer_subgraph)\n        current_p_yes = p.current_p_yes()\n        if not current_p_yes:\n            logger.info(\n                f\"p_yes for market {model.id.hex()} could not be calculated. Skipping.\"\n            )\n            return None\n\n        return SeerAgentMarket(\n            id=model.id.hex(),\n            question=model.title,\n            creator=model.creator,\n            created_time=model.created_time,\n            outcomes=model.outcomes,\n            collateral_token_contract_address_checksummed=model.collateral_token_contract_address_checksummed,\n            condition_id=model.condition_id,\n            url=model.url,\n            close_time=model.close_time,\n            wrapped_tokens=[Web3.to_checksum_address(i) for i in model.wrapped_tokens],\n            fees=MarketFees.get_zero_fees(),\n            outcome_token_pool=None,\n            resolution=model.get_resolution_enum(),\n            volume=None,\n            current_p_yes=current_p_yes,\n            seer_outcomes=model.outcome_as_enums,\n        )\n\n    @staticmethod\n    def get_binary_markets(\n        limit: int,\n        sort_by: SortBy,\n        filter_by: FilterBy = FilterBy.OPEN,\n        created_after: t.Optional[DatetimeUTC] = None,\n        excluded_questions: set[str] | None = None,\n    ) -> t.Sequence[\"SeerAgentMarket\"]:\n        seer_subgraph = SeerSubgraphHandler()\n        markets = seer_subgraph.get_binary_markets(\n            limit=limit, sort_by=sort_by, filter_by=filter_by\n        )\n\n        # We exclude the None values below because `from_data_model_with_subgraph` can return None, which\n        # represents an invalid market.\n        return [\n            market\n            for m in markets\n            if (\n                market := SeerAgentMarket.from_data_model_with_subgraph(\n                    model=m, seer_subgraph=seer_subgraph\n                )\n            )\n            is not None\n        ]\n\n    def has_liquidity_for_outcome(self, outcome: bool) -> bool:\n        outcome_token = self.get_wrapped_token_for_outcome(outcome)\n        pool = SeerSubgraphHandler().get_pool_by_token(\n            token_address=outcome_token,\n            collateral_address=self.collateral_token_contract_address_checksummed,\n        )\n        return pool is not None and pool.liquidity > 0\n\n    def has_liquidity(self) -> bool:\n        # We conservatively define a market as having liquidity if it has liquidity for the `True` outcome token AND the `False` outcome token.\n        return self.has_liquidity_for_outcome(True) and self.has_liquidity_for_outcome(\n            False\n        )\n\n    def get_wrapped_token_for_outcome(self, outcome: bool) -> ChecksumAddress:\n        outcome_from_enum = SeerOutcomeEnum.from_bool(outcome)\n        outcome_idx = self.seer_outcomes[outcome_from_enum]\n        outcome_token = self.wrapped_tokens[outcome_idx]\n        return outcome_token\n\n    def place_bet(\n        self,\n        outcome: bool,\n        amount: USD,\n        auto_deposit: bool = True,\n        web3: Web3 | None = None,\n        api_keys: APIKeys | None = None,\n    ) -> str:\n        api_keys = api_keys if api_keys is not None else APIKeys()\n        if not self.can_be_traded():\n            raise ValueError(\n                f\"Market {self.id} is not open for trading. Cannot place bet.\"\n            )\n\n        amount_in_token = self.get_usd_in_token(amount)\n        amount_wei = amount_in_token.as_wei\n        collateral_contract = self.get_collateral_token_contract()\n\n        if auto_deposit:\n            auto_deposit_collateral_token(\n                collateral_contract, amount_wei, api_keys, web3\n            )\n\n        collateral_balance = collateral_contract.balanceOf(api_keys.bet_from_address)\n        if collateral_balance < amount_wei:\n            raise ValueError(\n                f\"Balance {collateral_balance} not enough for bet size {amount}\"\n            )\n\n        outcome_token = self.get_wrapped_token_for_outcome(outcome)\n\n        #  Sell sDAI using token address\n        order_metadata = swap_tokens_waiting(\n            amount_wei=amount_wei,\n            sell_token=collateral_contract.address,\n            buy_token=outcome_token,\n            api_keys=api_keys,\n            web3=web3,\n        )\n        logger.debug(\n            f\"Purchased {outcome_token} in exchange for {collateral_contract.address}. Order details {order_metadata}\"\n        )\n\n        return order_metadata.uid.root\n\n    def sell_tokens(\n        self,\n        outcome: bool,\n        amount: USD | OutcomeToken,\n        auto_withdraw: bool = True,\n        api_keys: APIKeys | None = None,\n        web3: Web3 | None = None,\n    ) -> str:\n        \"\"\"\n        Sells the given number of shares for the given outcome in the given market.\n        \"\"\"\n        outcome_token = self.get_wrapped_token_for_outcome(outcome)\n        api_keys = api_keys if api_keys is not None else APIKeys()\n\n        token_amount = (\n            amount.as_outcome_wei.as_wei\n            if isinstance(amount, OutcomeToken)\n            else self.get_in_token(amount).as_wei\n        )\n\n        order_metadata = swap_tokens_waiting(\n            amount_wei=token_amount,\n            sell_token=outcome_token,\n            buy_token=Web3.to_checksum_address(\n                self.collateral_token_contract_address_checksummed\n            ),\n            api_keys=api_keys,\n            web3=web3,\n        )\n\n        logger.debug(\n            f\"Sold {outcome_token} in exchange for {self.collateral_token_contract_address_checksummed}. Order details {order_metadata}\"\n        )\n\n        return order_metadata.uid.root\n\n\ndef seer_create_market_tx(\n    api_keys: APIKeys,\n    initial_funds: USD | CollateralToken,\n    question: str,\n    opening_time: DatetimeUTC,\n    language: str,\n    outcomes: t.Sequence[OutcomeStr],\n    auto_deposit: bool,\n    category: str,\n    min_bond: xDai,\n    web3: Web3 | None = None,\n) -> ChecksumAddress:\n    web3 = web3 or SeerMarketFactory.get_web3()  # Default to Gnosis web3.\n\n    factory_contract = SeerMarketFactory()\n    collateral_token_address = factory_contract.collateral_token(web3=web3)\n    collateral_token_contract = to_gnosis_chain_contract(\n        init_collateral_token_contract(collateral_token_address, web3)\n    )\n\n    initial_funds_in_collateral = (\n        get_usd_in_token(initial_funds, collateral_token_address)\n        if isinstance(initial_funds, USD)\n        else initial_funds\n    )\n    initial_funds_in_collateral_wei = initial_funds_in_collateral.as_wei\n\n    if auto_deposit:\n        auto_deposit_collateral_token(\n            collateral_token_contract=collateral_token_contract,\n            api_keys=api_keys,\n            collateral_amount_wei_or_usd=initial_funds_in_collateral_wei,\n            web3=web3,\n        )\n\n    # Approve the market maker to withdraw our collateral token.\n    collateral_token_contract.approve(\n        api_keys=api_keys,\n        for_address=factory_contract.address,\n        amount_wei=initial_funds_in_collateral_wei,\n        web3=web3,\n    )\n\n    # Create the market.\n    params = factory_contract.build_market_params(\n        market_question=question,\n        outcomes=outcomes,\n        opening_time=opening_time,\n        language=language,\n        category=category,\n        min_bond=min_bond,\n    )\n    tx_receipt = factory_contract.create_categorical_market(\n        api_keys=api_keys, params=params, web3=web3\n    )\n\n    # ToDo - Add liquidity to market on Swapr (https://github.com/gnosis/prediction-market-agent-tooling/issues/497)\n    market_address = extract_market_address_from_tx(\n        factory_contract=factory_contract, tx_receipt=tx_receipt, web3=web3\n    )\n    return market_address\n\n\ndef extract_market_address_from_tx(\n    factory_contract: SeerMarketFactory, tx_receipt: TxReceipt, web3: Web3\n) -> ChecksumAddress:\n    \"\"\"We extract the newly created market from the NewMarket event emitted in the transaction.\"\"\"\n    event_logs = (\n        factory_contract.get_web3_contract(web3=web3)\n        .events.NewMarket()\n        .process_receipt(tx_receipt)\n    )\n    new_market_event = NewMarketEvent(**event_logs[0][\"args\"])\n    return Web3.to_checksum_address(new_market_event.market)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/prediction_market_agent_tooling/markets/seer/seer.py b/prediction_market_agent_tooling/markets/seer/seer.py
--- a/prediction_market_agent_tooling/markets/seer/seer.py	(revision df193bc64eb9546135e3df7faf33de60a10d2744)
+++ b/prediction_market_agent_tooling/markets/seer/seer.py	(date 1743687238198)
@@ -128,6 +128,7 @@
     def get_sell_value_of_outcome_token(
         self, outcome: str, amount: OutcomeToken
     ) -> CollateralToken:
+        #  ToDo Get collateral value of outcome tokens you hold
         if amount == amount.zero():
             return CollateralToken.zero()
 
@@ -135,9 +136,8 @@
         wrapped_outcome_token = self.wrapped_tokens[outcome_index]
 
         # We calculate how much collateral we would get back if we sold `amount` of outcome token.
-
         value_outcome_token_in_collateral = get_buy_token_amount_else_raise(
-            amount_wei=amount.as_outcome_wei.as_wei,
+            sell_amount=amount.as_outcome_wei.as_wei,
             sell_token=wrapped_outcome_token,
             buy_token=self.collateral_token_contract_address_checksummed,
         )
@@ -195,8 +195,8 @@
     ) -> ExistingPosition | None:
         try:
             return self.get_position_else_raise(user_id=user_id, web3=web3)
-        except Exception:
-            logger.info(f"Could not get position for user {user_id}")
+        except Exception as e:
+            logger.warning(f"Could not get position for user {user_id}, exception {e}")
             return None
 
     @staticmethod
Index: prediction_market_agent_tooling/tools/tokens/usd.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from cachetools import TTLCache, cached\n\nfrom prediction_market_agent_tooling.gtypes import (\n    USD,\n    ChecksumAddress,\n    CollateralToken,\n    xDai,\n)\nfrom prediction_market_agent_tooling.markets.omen.omen_constants import (\n    SDAI_CONTRACT_ADDRESS,\n    WRAPPED_XDAI_CONTRACT_ADDRESS,\n)\nfrom prediction_market_agent_tooling.tools.contract import ContractERC4626OnGnosisChain\nfrom prediction_market_agent_tooling.tools.cow.cow_order import (\n    get_buy_token_amount_else_raise,\n)\n\n\ndef get_usd_in_xdai(amount: USD) -> xDai:\n    # xDai is stable coin against USD, so for simplicity we just cast it.\n    return xDai(amount.value)\n\n\ndef get_xdai_in_usd(amount: xDai) -> USD:\n    # xDai is stable coin against USD, so for simplicity we just cast it.\n    return USD(amount.value)\n\n\ndef get_usd_in_token(amount: USD, token_address: ChecksumAddress) -> CollateralToken:\n    rate = get_single_usd_to_token_rate(token_address)\n    return CollateralToken(amount.value * rate.value)\n\n\ndef get_token_in_usd(amount: CollateralToken, token_address: ChecksumAddress) -> USD:\n    rate = get_single_token_to_usd_rate(token_address)\n    return USD(amount.value * rate.value)\n\n\n# A short cache to not spam CoW and prevent timeouts, but still have relatively fresh data.\n@cached(TTLCache(maxsize=100, ttl=5 * 60))\ndef get_single_token_to_usd_rate(token_address: ChecksumAddress) -> USD:\n    # (w)xDai is a stable coin against USD, so use it to estimate USD worth.\n    if WRAPPED_XDAI_CONTRACT_ADDRESS == token_address:\n        return USD(1.0)\n    # sDai is ERC4626 with wxDai as asset, we can take the rate directly from there instead of calling CoW.\n    if SDAI_CONTRACT_ADDRESS == token_address:\n        return USD(\n            ContractERC4626OnGnosisChain(address=SDAI_CONTRACT_ADDRESS)\n            .convertToAssets(CollateralToken(1).as_wei)\n            .as_token.value\n        )\n    in_wei = get_buy_token_amount_else_raise(\n        amount_wei=CollateralToken(1).as_wei,\n        sell_token=token_address,\n        buy_token=WRAPPED_XDAI_CONTRACT_ADDRESS,\n    )\n    in_token = in_wei.as_token\n    return USD(in_token.value)\n\n\n# A short cache to not spam CoW and prevent timeouts, but still have relatively fresh data.\n@cached(TTLCache(maxsize=100, ttl=5 * 60))\ndef get_single_usd_to_token_rate(token_address: ChecksumAddress) -> CollateralToken:\n    # (w)xDai is a stable coin against USD, so use it to estimate USD worth.\n    if WRAPPED_XDAI_CONTRACT_ADDRESS == token_address:\n        return CollateralToken(1.0)\n    # sDai is ERC4626 with wxDai as asset, we can take the rate directly from there instead of calling CoW.\n    if SDAI_CONTRACT_ADDRESS == token_address:\n        return CollateralToken(\n            ContractERC4626OnGnosisChain(address=SDAI_CONTRACT_ADDRESS)\n            .convertToShares(CollateralToken(1).as_wei)\n            .as_token.value\n        )\n    in_wei = get_buy_token_amount_else_raise(\n        amount_wei=CollateralToken(1).as_wei,\n        sell_token=WRAPPED_XDAI_CONTRACT_ADDRESS,\n        buy_token=token_address,\n    )\n    in_token = in_wei.as_token\n    return CollateralToken(in_token.value)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/prediction_market_agent_tooling/tools/tokens/usd.py b/prediction_market_agent_tooling/tools/tokens/usd.py
--- a/prediction_market_agent_tooling/tools/tokens/usd.py	(revision df193bc64eb9546135e3df7faf33de60a10d2744)
+++ b/prediction_market_agent_tooling/tools/tokens/usd.py	(date 1743687238211)
@@ -50,7 +50,7 @@
             .as_token.value
         )
     in_wei = get_buy_token_amount_else_raise(
-        amount_wei=CollateralToken(1).as_wei,
+        sell_amount=CollateralToken(1).as_wei,
         sell_token=token_address,
         buy_token=WRAPPED_XDAI_CONTRACT_ADDRESS,
     )
@@ -72,7 +72,7 @@
             .as_token.value
         )
     in_wei = get_buy_token_amount_else_raise(
-        amount_wei=CollateralToken(1).as_wei,
+        sell_amount=CollateralToken(1).as_wei,
         sell_token=WRAPPED_XDAI_CONTRACT_ADDRESS,
         buy_token=token_address,
     )
