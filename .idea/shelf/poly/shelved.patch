Index: prediction_market_agent_tooling/markets/polymarket/api.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import typing as t\n\nimport requests\nimport tenacity\nfrom loguru import logger\n\nfrom prediction_market_agent_tooling.markets.polymarket.data_models import (\n    POLYMARKET_FALSE_OUTCOME,\n    POLYMARKET_TRUE_OUTCOME,\n    MarketsEndpointResponse,\n    PolymarketMarket,\n    PolymarketMarketWithPrices,\n    PolymarketPriceResponse,\n    PolymarketTokenWithPrices,\n    Prices,\n)\nfrom prediction_market_agent_tooling.tools.utils import response_to_model\n\nPOLYMARKET_API_BASE_URL = \"https://clob.polymarket.com/\"\nMARKETS_LIMIT = 100  # Polymarket will only return up to 100 markets\n\n\n@tenacity.retry(\n    stop=tenacity.stop_after_attempt(5),\n    wait=tenacity.wait_chain(*[tenacity.wait_fixed(n) for n in range(1, 6)]),\n    after=lambda x: logger.debug(f\"get_polymarkets failed, {x.attempt_number=}.\"),\n)\ndef get_polymarkets(\n    limit: int,\n    with_rewards: bool = False,\n    next_cursor: str | None = None,\n) -> MarketsEndpointResponse:\n    url = (\n        f\"{POLYMARKET_API_BASE_URL}/{'sampling-markets' if with_rewards else 'markets'}\"\n    )\n    params: dict[str, str | int | float | None] = {\n        \"limit\": min(limit, MARKETS_LIMIT),\n    }\n    if next_cursor is not None:\n        params[\"next_cursor\"] = next_cursor\n    return response_to_model(requests.get(url, params=params), MarketsEndpointResponse)\n\n\ndef get_polymarket_binary_markets(\n    limit: int,\n    closed: bool | None = False,\n    excluded_questions: set[str] | None = None,\n    with_rewards: bool = False,\n    main_markets_only: bool = True,\n) -> list[PolymarketMarketWithPrices]:\n    \"\"\"\n    See https://learn.polymarket.com/trading-rewards for information about rewards.\n    \"\"\"\n\n    all_markets: list[PolymarketMarketWithPrices] = []\n    next_cursor: str | None = None\n\n    while True:\n        response = get_polymarkets(\n            limit, with_rewards=with_rewards, next_cursor=next_cursor\n        )\n\n        for market in response.data:\n            # Closed markets means resolved markets.\n            if closed is not None and market.closed != closed:\n                continue\n\n            # Skip markets that are inactive.\n            # Documentation does not provide more details about this, but if API returns them, website gives \"Oops...we didn't forecast this\".\n            if not market.active:\n                continue\n\n            # Skip also those that were archived.\n            # Again nothing about it in documentation and API doesn't seem to return them, but to be safe.\n            if market.archived:\n                continue\n\n            if excluded_questions and market.question in excluded_questions:\n                continue\n\n            # Atm we work with binary markets only.\n            if sorted(token.outcome for token in market.tokens) != [\n                POLYMARKET_FALSE_OUTCOME,\n                POLYMARKET_TRUE_OUTCOME,\n            ]:\n                continue\n\n            # This is pretty slow to do here, but our safest option at the moment. So keep it as the last filter.\n            # TODO: Add support for `description` for `AgentMarket` and if it isn't None, use it in addition to the question in all agents. Then this can be removed.\n            if main_markets_only and not market.fetch_if_its_a_main_market():\n                continue\n\n            tokens_with_price = get_market_tokens_with_prices(market)\n            market_with_prices = PolymarketMarketWithPrices.model_validate(\n                {**market.model_dump(), \"tokens\": tokens_with_price}\n            )\n\n            all_markets.append(market_with_prices)\n\n        if len(all_markets) >= limit:\n            break\n\n        next_cursor = response.next_cursor\n\n        if next_cursor == \"LTE=\":\n            # 'LTE=' means the end.\n            break\n\n    return all_markets[:limit]\n\n\ndef get_polymarket_market(condition_id: str) -> PolymarketMarket:\n    url = f\"{POLYMARKET_API_BASE_URL}/markets/{condition_id}\"\n    return response_to_model(requests.get(url), PolymarketMarket)\n\n\ndef get_token_price(\n    token_id: str, side: t.Literal[\"buy\", \"sell\"]\n) -> PolymarketPriceResponse:\n    url = f\"{POLYMARKET_API_BASE_URL}/price\"\n    params = {\"token_id\": token_id, \"side\": side}\n    return response_to_model(requests.get(url, params=params), PolymarketPriceResponse)\n\n\ndef get_market_tokens_with_prices(\n    market: PolymarketMarket,\n) -> list[PolymarketTokenWithPrices]:\n    tokens_with_prices = [\n        PolymarketTokenWithPrices(\n            token_id=token.token_id,\n            outcome=token.outcome,\n            winner=token.winner,\n            prices=Prices(\n                BUY=get_token_price(token.token_id, \"buy\").price_dec,\n                SELL=get_token_price(token.token_id, \"sell\").price_dec,\n            ),\n        )\n        for token in market.tokens\n    ]\n    return tokens_with_prices\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/prediction_market_agent_tooling/markets/polymarket/api.py b/prediction_market_agent_tooling/markets/polymarket/api.py
--- a/prediction_market_agent_tooling/markets/polymarket/api.py	(revision 43b540d36ab9518d7cc3e0f76878e218a817b558)
+++ b/prediction_market_agent_tooling/markets/polymarket/api.py	(date 1727901404238)
@@ -17,6 +17,7 @@
 from prediction_market_agent_tooling.tools.utils import response_to_model
 
 POLYMARKET_API_BASE_URL = "https://clob.polymarket.com/"
+POLYMARKET_API_MARKETS_BASE_URL = "https://gamma-api.polymarket.com"
 MARKETS_LIMIT = 100  # Polymarket will only return up to 100 markets
 
 
@@ -41,6 +42,36 @@
     return response_to_model(requests.get(url, params=params), MarketsEndpointResponse)
 
 
+def get_polymarkets2(
+    limit: int,
+    closed: bool = False,
+):
+    url = f"{POLYMARKET_API_MARKETS_BASE_URL}/markets"
+    offset = 0
+    items = []
+    while len(items) < limit:
+        params: dict[str, str | int | float | None] = {
+            "limit": min(limit, MARKETS_LIMIT),
+            "closed": int(closed),
+            "offset": offset,
+            "order": "createdAt",
+            "archived": 0,  # we never fetch archived markets
+        }
+        r = requests.get(
+            POLYMARKET_API_MARKETS_BASE_URL
+            + "/markets?limit=2&order=id&ascending=1&offset=1000000",
+            params=params,
+        )
+        r.raise_for_status()
+        markets = r.json()
+        if not markets:
+            break
+        items.extend(markets)
+        offset += params["limit"]
+
+    return items
+
+
 def get_polymarket_binary_markets(
     limit: int,
     closed: bool | None = False,
